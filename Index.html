<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEAT THE VEGGIE</title>
    <style>
        /* Globale Styles */
        body, html {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #050505;
            color: white;
            overflow: auto;
            box-sizing: border-box;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        /* Game Container */
        #game-container {
            position: relative;
            width: 98vw;
            height: calc(100vh - 220px);
            max-width: 1200px;
            max-height: 650px;
            background-color: darkgray;
            overflow: hidden;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            box-sizing: border-box;
        }

        /* Game Header */
        #game-header {
            width: 100%;
            height: 40px;
            min-height: 40px;
            background-color: #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            box-sizing: border-box;
            font-size: 1.1em;
            color: white;
            z-index: 100;
        }

        #player-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        #score-info {
            display: flex;
            gap: 15px;
            font-size: 0.9em;
        }

        /* Game Area */
        #game-area {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #050505;
            overflow: hidden;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #050505;
        }

        /* Mond und Effekte */
        #moon, #lightning-effect, #ufo-effect {
            position: absolute;
            z-index: 1; /* Standardwert, wird bei Bedarf angepasst */
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #moon {
            top: 2vh;
            right: 5%;
            font-size: 24vw;
            max-font-size: 500px;
            color: #ccc;
            animation: rotateMoon 120s linear infinite;
        }

        @keyframes rotateMoon {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        #lightning-effect {
            font-size: calc(24vw + 1vw);
            max-font-size: 501px;
            color: yellow;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            opacity: 0;
            transition: opacity 0.1s ease-in-out;
        }

        #ufo-effect {
            font-size: 12vw;
            max-font-size: 200px;
            z-index: 1; /* Über dem Mond */
            opacity: 0; /* Standardmäßig versteckt */
            transition: opacity 0.5s ease-in-out;
            /* Diese CSS-Zentrierung wird nun im JS überschrieben, wenn der Alien-Modus aktiv ist */
            /* left: 50%; top: 50%; transform: translate(-50%, -50%); */
        }

        /* Controls */
        #controls {
            width: 100vw;
            max-width: 1200px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-top: 10px;
            padding: 0 15px 5px 15px;
            box-sizing: border-box;
        }

        #left-controls {
            display: flex;
            flex-direction: column;
            gap: 5px; /* Abstand zwischen den Tasten */
            justify-content: flex-end; /* Tasten am unteren Rand ausrichten */
            height: 100%; /* Wichtig, damit gap funktioniert */
        }

        #right-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            justify-content: flex-end;
            height: 100%;
        }

        .control-button {
            background-color: black; /* Changed to black */
            color: white;
            border: none;
            border-radius: 10px;
            font-size: calc((16vw * 0.5 * 3) * 0.75); /* Angepasst für flexible Font-Größe */
            max-font-size: calc((40px * 3) * 0.75); /* Max Font-Größe */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            box-shadow: 0 5px 0 #333; /* Darker shadow for black button */
            transition: background-color 0.1s, box-shadow 0.1s;
        }

        #shoot-button {
            width: calc(16vw / 2 * 4);
            height: calc(16vw / 2 * 4);
            max-width: 320px;
            max-height: 320px;
            font-size: 8em;
            border-radius: 10px;
            margin-top: auto;
        }

        #jump-button, #crouch-button {
            /* Die Größe wird von shoot-button übernommen, dann halbiert */
            width: calc(var(--button-width) / 2);
            height: calc(var(--button-height) / 2);
            font-size: 4em; /* Font-Größe auch halbieren */
            border-radius: 10px;
            /* Für crouch-button: margin-top ist standardmäßig 5px von gap */
        }

        #jump-button {
            margin-bottom: 5px; /* Abstand zur Crouch-Taste, wenn flex-direction column */
        }


        .control-button:active {
            background-color: #333; /* Darker on active */
            box-shadow: 0 2px 0 #111; /* Even darker shadow */
            transform: translateY(3px);
        }

        /* Overlays */
        #start-screen, #level-complete-screen, #game-over-screen, #well-done-screen, #shop-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2em;
            z-index: 10;
            padding: 10px;
            box-sizing: border-box;
        }

        .game-overlay-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0);
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 6vw;
            max-font-size: 2em;
            color: white;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            text-transform: uppercase;
            white-space: nowrap;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .game-overlay-message .message-emoji {
            font-size: 8vw;
            max-font-size: 3em;
        }

        .game-overlay-message.show {
            opacity: 1;
        }

        .hidden {
            display: none !important;
        }

        /* Start Screen */
        #start-screen h1 {
            font-size: 10vw;
            max-font-size: 4em;
            color: #006400;
            margin-bottom: 20px;
        }

        #start-screen .meat-the-veggie-text {
            color: white;
            opacity: 1;
            z-index: 0;
        }

        #start-screen input[type="text"] {
            padding: 10px;
            font-size: 1em;
            margin: 15px 0;
            width: 80%;
            max-width: 300px;
            border-radius: 5px;
            border: none;
            text-align: center;
            box-sizing: border-box;
        }

        #character-selection {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            width: 90%;
            max-width: 600px;
        }

        .character-card {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            border: 2px solid transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 25vw;
            max-width: 120px;
            box-sizing: border-box;
        }

        .character-card.selected {
            border: 2px solid gold;
            transform: scale(1.05);
            background-color: rgba(255, 215, 0, 0.2);
        }

        .character-card:hover {
            transform: scale(1.03);
        }

        .character-card p {
            margin: 5px 0 0 0;
            font-weight: bold;
            font-size: 0.9em;
        }

        .character-card .char-emoji {
            font-size: 6vw;
            max-font-size: 3em;
            margin-bottom: 5px;
        }

        .character-card .char-details {
            display: none;
        }

        /* Shop Screen */
        #shop-screen h2 {
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        #shop-items-container {
            display: flex;
            flex-direction: column; /* Alle Items untereinander */
            gap: 8px;
            width: 90%;
            max-width: 600px;
            margin-bottom: 15px;
            overflow-y: auto;
            max-height: 70vh;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            box-sizing: border-box;
        }

        .shop-item {
            display: grid; /* Verwende Grid für die Spaltenanordnung */
            grid-template-columns: 1fr auto auto; /* Name, Preis, Button */
            align-items: center;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9em;
            gap: 10px; /* Abstand zwischen den Spalten */
        }

        .shop-item-info {
            display: flex;
            flex-direction: column; /* Bild über dem Namen */
            align-items: flex-start;
            flex-grow: 1; /* Nimmt den restlichen Platz ein */
        }

        .shop-item-info .item-icon {
            font-size: 1.5em; /* Größe des Item-Emojis */
            margin-bottom: 2px; /* Kleiner Abstand zwischen Bild und Name */
        }

        .shop-item-info .item-name {
            font-size: 0.7em; /* Schriftgröße um 30% kleiner (0.9 * 0.7 = 0.63) */
            line-height: 1.2; /* Zeilenhöhe anpassen */
        }

        .shop-item .price {
            text-align: right;
            white-space: nowrap; /* Preis bleibt in einer Zeile */
        }

        .shop-item button {
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .shop-item button:hover {
            background-color: #45a049;
        }

        .shop-item.purchased {
            opacity: 0.6;
        }

        .shop-item.purchased button {
            background-color: #888;
            cursor: not-allowed;
        }

        /* Game Buttons */
        .game-button {
            padding: 12px 25px;
            font-size: 1.3em;
            margin: 8px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .game-button:hover {
            background-color: #45a049;
        }

        /* Game Over Screen */
        #game-over-screen p {
            font-size: 8vw;
            max-font-size: 3.5em;
            margin: 20px 0;
        }

        /* Well Done Screen */
        #well-done-screen p {
            margin: 5px 0;
            font-size: 1.1em;
        }
        #well-done-screen p span {
            font-size: 1.2em;
        }

        /* Copyright */
        #copyright {
            color: gray;
            font-size: 0.75em;
            white-space: nowrap;
            z-index: 1000;
            margin-top: 10px;
            position: absolute;
            bottom: 5px;
            width: 100%;
            text-align: center;
        }

        /* Media Queries */
        @media (max-height: 600px), (max-width: 600px) {
            #start-screen h1 { font-size: 8vw; }
            .character-card { padding: 8px; min-width: 30vw; }
            .character-card .char-emoji { font-size: 8vw; }

            #shoot-button {
                width: calc(20vw / 2 * 4);
                height: calc(20vw / 2 * 4);
                font-size: 8em;
            }
            #jump-button, #crouch-button {
                /* Größen werden von JS gesetzt */
                width: calc(var(--button-width) / 2); /* Halbiert */
                height: calc(var(--button-height) / 2); /* Halbiert */
                font-size: 4em; /* Font-Größe auch halbieren */
            }

            #game-header { font-size: 1em; height: 35px; min-height: 35px; }
            #score-info { gap: 10px; font-size: 0.85em; }
            .game-overlay-message { font-size: 5vw; padding: 15px 30px; }
            .game-button { padding: 10px 20px; font-size: 1.1em; margin: 6px; }
            #game-over-screen p { font-size: 6vw; }
            #moon { font-size: 30vw; }
            #lightning-effect { font-size: calc(30vw + 1vw); }
            #ufo-effect { font-size: 15vw; }
        }
    </style>
</head>
<body>
    <div id="game-container" class="hidden">
        <div id="game-header">
            <div id="player-info">
                <span id="player-character-logo"></span>
                <span id="player-name-display"></span>
            </div>
            <div id="score-info">
                <span>🪦 <span id="kills-display">0</span></span>
                <span>🪙 <span id="gold-display">0</span></span>
                <span id="lives-display">♥️♥️♥️♥️♥️</span>
            </div>
        </div>
        <div id="game-area">
            <canvas id="game-canvas"></canvas>
            <div id="moon"></div>
            <div id="lightning-effect">⚡️</div>
            <div id="ufo-effect">🛸</div>
        </div>

        <div id="level-complete-screen" class="hidden">
            <h2>LEVEL ABGESCHLOSSEN!</h2>
            <button id="shop-button" class="game-button">SHOP</button>
            <button id="next-level-button" class="game-button">WEITER</button>
            <button id="quit-game-button" class="game-button">AUFHÖREN</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h2>STEAK OVER BABY</h2>
            <p>⚰️</p>
            <button id="restart-button" class="game-button">NOCHMAL</button>
        </div>

        <div id="well-done-screen" class="hidden">
            <h2>WELL DONE</h2>
            <p><span id="final-player-logo"></span> <span id="final-player-name"></span></p>
            <p>🪙 <span id="final-gold">0</span></p>
            <p>🪦 <span id="final-kills">0</span></p>
            <p>💀 <span id="final-deaths">0</span></p>
            <button id="back-to-start-button" class="game-button">ZURÜCK ZUM START</button>
        </div>

        <div id="shop-screen" class="hidden">
            <h2>SHOP</h2>
            <div id="shop-items-container">
            </div>
            <button id="back-to-level-complete-button" class="game-button">ZURÜCK</button>
        </div>

    </div>

    <div id="start-screen">
        <h1 id="start-screen-title"></h1>
        <input type="text" id="player-name-input" placeholder="Dein Name">
        <div id="character-selection">
            <div class="character-card" data-character="neptun">
                <p class="char-emoji">🧜‍♂️</p>
                <p>NEPTUN</p>
            </div>
            <div class="character-card" data-character="zahnfee">
                <p class="char-emoji">🧚‍♀️</p>
                <p>ZAHNFEE</p>
            </div>
            <div class="character-card" data-character="dschinn">
                <p class="char-emoji">🧞</p>
                <p>DSCHINN</p>
            </div>
            <div class="character-card" data-character="zwillinge">
                <p class="char-emoji">👯‍♀️</p>
                <p>ZWILLINGE</p>
            </div>
        </div>
        <button id="start-game-button" class="game-button hidden">GUTEN APPETIT</button>
    </div>

    <div id="controls" class="hidden">
        <div id="left-controls">
            <button id="jump-button" class="control-button">⬆️</button>
            <button id="crouch-button" class="control-button">⬇️</button>
        </div>
        <div id="right-controls">
                       <button id="shoot-button" class="control-button">✴️</button>
        </div>
    </div>

    <div id="copyright">Copyright 2025 JQ GAMES</div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const gameArea = document.getElementById('game-area');
        const gameCanvas = document.getElementById('game-canvas');
        const ctx = gameCanvas.getContext('2d');

        const playerNameInput = document.getElementById('player-name-input');
        const characterSelection = document.getElementById('character-selection');
        const startGameButton = document.getElementById('start-game-button');
        const jumpButton = document.getElementById('jump-button');
        const crouchButton = document.getElementById('crouch-button');
        const shootButton = document.getElementById('shoot-button');
        const startScreen = document.getElementById('start-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const wellDoneScreen = document.getElementById('well-done-screen');
        const shopScreen = document.getElementById('shop-screen');
        const shopItemsContainer = document.getElementById('shop-items-container');
        const controlsDiv = document.getElementById('controls');
        const startScreenTitle = document.getElementById('start-screen-title');
        const moonElement = document.getElementById('moon');
        const lightningEffectElement = document.getElementById('lightning-effect');
        const ufoEffectElement = document.getElementById('ufo-effect');

        const playerCharacterLogoDisplay = document.getElementById('player-character-logo');
        const playerNameDisplay = document.getElementById('player-name-display');
        const killsDisplay = document.getElementById('kills-display');
        const goldDisplay = document.getElementById('gold-display');
        const livesDisplay = document.getElementById('lives-display');

        const nextLevelButton = document.getElementById('next-level-button');
        const shopButton = document.getElementById('shop-button');
        const quitGameButton = document.getElementById('quit-game-button');
        const restartButton = document.getElementById('restart-button');
        const backToStartButton = document.getElementById('back-to-start-button');
        const backToLevelCompleteButton = document.getElementById('back-to-level-complete-button');


        let playerName = '';
        let selectedCharacter = null;
        let playerLives = 5;
        let playerGold = 0;
        let enemiesKilled = 0;
        let playerDeaths = 0;
        let currentLevel = 0;
        let enemiesInLevel = 0;
        let enemiesSpawned = 0;
        let enemiesDefeatedInLevel = 0;
        let isJumping = false;
        let isCrouching = false;
        let isShootingPressed = false;
        let playerY = 0;
        let playerX = 50;
        let playerWidth = 0;
        let playerHeight = 0;

        const jumpHeight = 150;
        const jumpSpeed = 8;
        let gravity = 0.4;
        let playerBulletSpeed = 5 * 1.2;
        let playerShootInterval = 300;
        let playerLastShotTime = 0;
        let playerBulletIcon = '';
        let playerBulletDamage = 1;
        let playerBulletCount = 1;

        let activeItems = [];
        let alienModeActive = false;
        let alienModeTimeout = null;
        let currentMessageElement = null;
        let ufoBullets = [];
        let ufoLastDamageTime = 0;
        const ufoDamageInterval = 166; /* War 500, jetzt 3x schneller */
        const ufoBulletSpeed = 3;

        const backgroundElements = [];
        const enemies = [];
        const playerBullets = [];
        const enemyBullets = [];
        const levelItems = [];
        const impactEffects = [];
        let bossLivesIncrease = 0;
        let bossSpawned = false;


        const BASE_FONT_SIZE_PLAYER = 0.12;
        const BASE_FONT_SIZE_BULLET = 0.04;
        const BASE_FONT_SIZE_BACKGROUND = 0.06;
        const BASE_FONT_SIZE_ITEM = 0.07;
        const BASE_FONT_SIZE_IMPACT = 0.06;
        const GROUND_HEIGHT_RATIO = 0.1;

        let groundHeight = 0;

        const characterProperties = {
            neptun: {
                logo: '🧜‍♂️',
                name: 'NEPTUN',
                startLives: 5,
                shootSpeedMultiplier: 2.5,
                bulletIcon: '🍗',
                startGold: 0,
                bulletCount: 1,
                shootIntervalModifier: 1
            },
            zahnfee: {
                logo: '🧚‍♀️',
                name: 'ZAHNFEE',
                startLives: 7,
                shootSpeedMultiplier: 1,
                bulletIcon: '🌭',
                startGold: 0,
                bulletCount: 1,
                shootIntervalModifier: 1
            },
            dschinn: {
                logo: '🧞',
                name: 'DSCHINN',
                startLives: 5,
                shootSpeedMultiplier: 1,
                bulletIcon: '🥩',
                startGold: 5,
                bulletCount: 1,
                shootIntervalModifier: 1
            },
            zwillinge: {
                logo: '👯‍♀️',
                name: 'ZWILLINGE',
                startLives: 5,
                shootSpeedMultiplier: 1,
                bulletIcon: '🥓',
                startGold: 0,
                bulletCount: 2,
                shootIntervalModifier: 1
            }
        };

        const enemyTypes = {
            blacky: {
                icon: '🕴️',
                shootSpeed: 1 * 2,
                shootPause: 3000 * 1.2,
                speed: 0.7 * 1.5,
                lives: 1 * 2 + 1,
                frequency: 50,
                gold: 1,
                bulletIcon: '🍆',
                canJump: true,
                jumpSpeed: 6,
                baseSizeModifier: 1
            },
            zombie: {
                icon: '🧌',
                shootSpeed: 1 * 2,
                shootPause: 3000 * 1.2,
                speed: 0.3 * 1.5,
                lives: 3 * 2 + 1,
                frequency: 35,
                gold: 2,
                bulletIcon: '🥦',
                canJump: true,
                jumpSpeed: 0,
                baseSizeModifier: 2
            },
            driver: {
                icon: '👨‍🦽',
                shootSpeed: 2 * 2,
                shootPause: 4000 * 1.2,
                speed: 1.5 * 1.5,
                lives: 1 * 2 + 1,
                frequency: 15,
                gold: 1,
                bulletIcon: '🌶',
                canJump: false,
                jumpSpeed: 0,
                baseSizeModifier: 1
            }
        };

        const bossType = {
            bossy: {
                icon: '🫚',
                shootSpeed: 3 * 1.5,
                shootPause: 300 * 1.2,
                speed: 0,
                lives: 15 * 2 * 2,
                gold: 5,
                bulletIcon: '🍍',
                canJump: true,
                canCrouch: true,
                jumpSpeed: 7,
                jumpFrequency: 0.02,
                crouchFrequency: 0.02,
                crouchDuration: 2500,
                baseSizeModifier: 2
            }
        };

        const itemTypes = {
            sandwich: {
                icon: '🥪',
                name: 'Sandwich',
                frequency: 20,
                apply: (player) => {
                    player.bulletCount += 1;
                    player.bulletIcon = '🥪';
                },
                duration: 0,
                canBeShot: true,
                lives: 8
            },
            garnele: {
                icon: '🍤',
                name: 'Garnele',
                frequency: 20,
                apply: (player) => {
                    player.shootInterval /= 2;
                    player.bulletDamage += 1;
                    player.bulletIcon = '🍤';
                },
                reverse: (player) => {
                    player.shootInterval *= 2;
                    player.bulletDamage -= 1;
                    player.bulletIcon = characterProperties[selectedCharacter].bulletIcon;
                },
                duration: 10000,
                canBeShot: true,
                lives: 8
            },
            pancake: {
                icon: '🥞',
                name: 'Pancake',
                frequency: 20,
                apply: (player) => {
                    player.bulletCount += 1;
                    player.bulletDamage += 1;
                    player.bulletIcon = '🥞';
                },
                reverse: (player) => {
                    player.bulletCount -= 1;
                    player.bulletDamage -= 1;
                    player.bulletIcon = characterProperties[selectedCharacter].bulletIcon;
                },
                duration: 10000,
                canBeShot: true,
                lives: 8
            },
            gold: {
                icon: '🪙',
                name: 'Goldmünze',
                frequency: 20,
                apply: (player) => {
                    playerGold += 10;
                    updateGoldDisplay();
                },
                duration: 0,
                canBeShot: true,
                lives: 8
            },
            alien: {
                icon: '👽',
                name: 'Alien',
                frequency: 20,
                apply: (player) => {
                    activateAlienMode();
                },
                duration: 0,
                canBeShot: true,
                lives: 8
            }
        };

        const shopItems = {
            burger: {
                icon: '🍔',
                name: 'BURGER',
                price: Math.round(7 * 3 * 1.5),
                purchased: false,
                apply: (player) => {
                    player.shootInterval = Math.max(50, player.shootInterval - 50);
                    player.bulletIcon = '🍔';
                }
            },
            keule: {
                icon: '🍖',
                name: 'KEULE',
                price: Math.round(10 * 3 * 1.5),
                purchased: false,
                apply: (player) => {
                    player.bulletCount += 1;
                }
            },
            sweetpong: {
                icon: '🏓',
                name: 'SWEETPONG',
                price: Math.round(14 * 3 * 1.5),
                purchased: false,
                apply: (player) => {
                    player.shootInterval = Math.max(50, player.shootInterval - 50);
                    player.bulletCount += 1;
                    player.bulletIcon = '🍬';
                }
            },
            schwammerl: {
                icon: '🍄',
                name: 'SCHWAMMERL',
                price: Math.round(10 * 3 * 1.5),
                purchased: false,
                apply: (player) => {
                    player.enemyShootSpeedModifier = 0.5;
                },
                reverse: (player) => {
                    player.enemyShootSpeedModifier = 1;
                },
                duration: 15000
            },
            schweinerei: {
                icon: '🐽',
                name: 'SCHWEINEREI',
                price: Math.round(14 * 3 * 1.5),
                purchased: false,
                apply: (player) => {
                    playerLives = Math.max(0, playerLives - 1);
                    player.bulletCount *= 2;
                    player.bulletIcon = '🪱';
                    updateLivesDisplay();
                }
            },
            gemueseSchneiden: {
                icon: '🔪',
                name: 'GEMÜSE HEXELN',
                price: Math.round(6 * 3 * 1.5),
                purchased: false,
                apply: (player) => {
                    player.enemySpeedModifier = 0.5;
                },
                reverse: (player) => {
                    player.enemySpeedModifier = 1;
                },
                duration: 15000
            },
            yogi: {
                icon: '🧘‍♂️',
                name: 'YOGI',
                price: Math.round(20 * 3 * 1.5),
                purchased: false,
                apply: (player) => {
                    player.logo = '🧘‍♂️';
                    player.bulletDamage += 2;
                    player.shootInterval = Math.max(50, player.shootInterval - 150);
                    player.bulletCount += 1;
                    player.bulletIcon = '🪬';
                    playerCharacterLogoDisplay.textContent = player.logo;
                }
            }
        };


        let gameRunning = false;
        let gameLoopInterval;
        let enemySpawnInterval;
        let itemSpawnTimeout;
        let lightningTimeout;
        let gamePlayer = {};


        let lastLightningTime = 0;

        function startLightningTimer() {
            if (!gameRunning) return;

            const minTime = 5000;
            const maxTime = 10000;
            const nextLightningInterval = Math.random() * (maxTime - minTime) + minTime;

            lightningTimeout = setTimeout(() => {
                showLightning();
                startLightningTimer();
            }, nextLightningInterval);
        }

        function showLightning() {
            const moonRect = moonElement.getBoundingClientRect();
            const gameAreaRect = gameArea.getBoundingClientRect();

            lightningEffectElement.style.left = `${(moonRect.left - gameAreaRect.left - lightningEffectElement.offsetWidth - 10)}px`;
            lightningEffectElement.style.top = `${moonRect.top - gameAreaRect.top + 30}px`;

            lightningEffectElement.style.opacity = '0.7';
            setTimeout(() => {
                lightningEffectElement.style.opacity = '0';
            }, 500);
        }


        function getScaledFontSize(baseRatio) {
            const minFontSize = 10;
            const maxFontSize = 150;
            return Math.min(maxFontSize, Math.max(minFontSize, Math.floor(gameCanvas.height * baseRatio)));
        }

        function getEmojiMetrics(emoji, fontSize) {
            ctx.font = `${fontSize}px Arial`;
            const metrics = ctx.measureText(emoji);
            const width = metrics.width;
            const height = fontSize;
            return { width, height };
        }

        function drawCharacter(character, x, y, icon, isCrouching = false, isFlipped = false) {
            ctx.save();

            let fontSize;
            if (character.isBoss && isCrouching) {
                fontSize = getScaledFontSize(bossType.bossy.baseSizeModifier * BASE_FONT_SIZE_PLAYER / 2);
            } else if (isCrouching) {
                fontSize = getScaledFontSize(BASE_FONT_SIZE_PLAYER / 2);
            } else if (character.isBoss) {
                fontSize = getScaledFontSize(bossType.bossy.baseSizeModifier * BASE_FONT_SIZE_PLAYER);
            } else {
                fontSize = getScaledFontSize(BASE_FONT_SIZE_PLAYER);
            }

            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'alphabetic';

            const charMetrics = getEmojiMetrics(icon, fontSize);
            const drawX = x + charMetrics.width / 2;
            const drawY = gameCanvas.height - y;

            if (isFlipped) {
                ctx.translate(drawX, drawY);
                ctx.scale(-1, 1);
                ctx.fillText(icon, 0, 0);
            } else {
                ctx.fillText(icon, drawX, drawY);
            }
            ctx.restore();
        }

        function drawBullet(bullet) {
            ctx.save();
            const fontSize = getScaledFontSize(BASE_FONT_SIZE_BULLET);
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const bulletMetrics = getEmojiMetrics(bullet.icon, fontSize);
            const drawX = bullet.x + bulletMetrics.width / 2;
            const drawY = bullet.y + bulletMetrics.height / 2;

            ctx.translate(drawX, drawY);
            ctx.rotate(bullet.rotation * Math.PI / 180);
            ctx.fillText(bullet.icon, 0, 0);
            ctx.restore();
        }

        function drawImpact(impact) {
            ctx.save();
            const fontSize = getScaledFontSize(BASE_FONT_SIZE_IMPACT);
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(impact.icon, impact.x, impact.y);
            ctx.restore();
        }

        function drawLevelItem(item) {
            ctx.save();
            const fontSize = getScaledFontSize(BASE_FONT_SIZE_ITEM);
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'alphabetic';

            const itemMetrics = getEmojiMetrics(item.icon, fontSize);
            const drawX = item.x + itemMetrics.width / 2;
            const drawY = gameCanvas.height - item.y;

            ctx.fillText(item.icon, drawX, drawY);
            ctx.restore();
        }

        function drawBackgroundElement(element) {
            ctx.save();
            const fontSize = getScaledFontSize(BASE_FONT_SIZE_BACKGROUND * element.sizeMultiplier);
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            const elementMetrics = getEmojiMetrics(element.icon, fontSize);
            const drawX = element.x + elementMetrics.width / 2;
            const drawY = gameCanvas.height - groundHeight;

            ctx.fillText(element.icon, drawX, drawY);
            ctx.restore();
        }

        function drawGround() {
            ctx.fillStyle = '#556B2F';
            ctx.fillRect(0, gameCanvas.height - groundHeight, gameCanvas.width, groundHeight);
        }

        function initGame() {
            playerLives = 5;
            playerGold = 0;
            enemiesKilled = 0;
            playerDeaths = 0;
            currentLevel = 0;
            enemiesInLevel = 30;
            enemiesSpawned = 0;
            enemiesDefeatedInLevel = 0;
            bossSpawned = false;
            bossLivesIncrease = 0;
            enemies.length = 0;
            playerBullets.length = 0;
            enemyBullets.length = 0;
            ufoBullets.length = 0;
            levelItems.length = 0;
            activeItems.length = 0;
            impactEffects.length = 0;
            ufoEffectElement.style.opacity = '0';
            ufoEffectElement.style.transform = ''; /* Reset transform for dynamic positioning */


            backgroundElements.length = 0;

            startScreen.classList.remove('hidden');
            gameContainer.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            wellDoneScreen.classList.add('hidden');
            shopScreen.classList.add('hidden');
            controlsDiv.classList.add('hidden');

            playerNameInput.value = '';
            document.querySelectorAll('.character-card').forEach(card => card.classList.remove('selected'));
            selectedCharacter = null;
            startGameButton.classList.add('hidden');

            clearInterval(gameLoopInterval);
            clearInterval(enemySpawnInterval);
            clearTimeout(itemSpawnTimeout);
            clearTimeout(lightningTimeout);
            if (alienModeTimeout) {
                clearTimeout(alienModeTimeout);
                alienModeTimeout = null;
            }
            alienModeActive = false;

            for (const key in shopItems) {
                shopItems[key].purchased = false;
            }

            resizeGameArea();
            checkStartButtonVisibility();
            startScreenTitle.textContent = 'MEAT THE VEGGIE';
            moonElement.textContent = '🌑';
        }

        function startGame() {
            if (!playerName) {
                alert('Bitte gib deinen Namen ein!');
                return;
            }
            if (!selectedCharacter) {
                alert('Bitte wähle einen Charakter aus!');
                return;
            }

            const charProps = characterProperties[selectedCharacter];
            gamePlayer = {
                logo: charProps.logo,
                name: playerName,
                lives: charProps.startLives,
                gold: charProps.startGold,
                bulletIcon: charProps.bulletIcon,
                shootSpeedMultiplier: charProps.shootSpeedMultiplier,
                shootInterval: charProps.shootIntervalModifier * 300 * 0.8,
                bulletDamage: 1,
                bulletCount: charProps.bulletCount,
                enemyShootSpeedModifier: 1,
                enemySpeedModifier: 1
            };

            playerLives = gamePlayer.lives;
            playerGold = gamePlayer.gold;

            playerCharacterLogoDisplay.textContent = gamePlayer.logo;
            playerNameDisplay.textContent = gamePlayer.name;
            updateLivesDisplay();
            updateGoldDisplay();
            updateKillsDisplay();

            startScreen.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            controlsDiv.classList.remove('hidden');
            gameRunning = true;
            resizeGameArea();
            resetPlayerPosition();
            startLevel(1);
            gameLoopInterval = setInterval(gameLoop, 1000 / 60);
            startLightningTimer();
        }

        function startLevel(level) {
            currentLevel = level;
            enemiesInLevel = 30 + (currentLevel - 1) * 10;
            enemiesSpawned = 0;
            enemiesDefeatedInLevel = 0;
            bossSpawned = false;
            enemies.length = 0;
            playerBullets.length = 0;
            enemyBullets.length = 0;
            ufoBullets.length = 0;
            levelItems.length = 0;
            impactEffects.length = 0;
            ufoEffectElement.style.opacity = '0';
            ufoEffectElement.style.transform = ''; /* Reset transform for dynamic positioning */
            clearInterval(enemySpawnInterval);
            clearTimeout(itemSpawnTimeout);
            if (alienModeTimeout) {
                clearTimeout(alienModeTimeout);
                alienModeTimeout = null;
            }
            alienModeActive = false;

            showGameMessage(`LEVEL ${currentLevel}`);

            enemySpawnInterval = setInterval(spawnEnemy, 1500);

            itemSpawnTimeout = setTimeout(() => {
                spawnItemBox();
            }, Math.random() * 5000 + 5000);
        }

        function spawnEnemy() {
            if (enemiesSpawned >= enemiesInLevel && !bossSpawned) {
                clearInterval(enemySpawnInterval);
                createEnemy(bossType.bossy, true);
                bossSpawned = true;
                showGameMessage(`BOSS FIGHT`, '🫚');
                return;
            }

            if (enemiesSpawned < enemiesInLevel) {
                const random = Math.random() * 100;
                let enemyType;
                let cumulativeFrequency = 0;
                const types = Object.values(enemyTypes);
                for (let i = 0; i < types.length; i++) {
                    cumulativeFrequency += types[i].frequency;
                    if (random < cumulativeFrequency) {
                        enemyType = types[i];
                        break;
                    }
                }
                if (!enemyType) {
                    enemyType = enemyTypes.blacky;
                }

                createEnemy(enemyType);
                enemiesSpawned++;
            }
        }

        function updateLivesDisplay() {
            let hearts = '';
            const maxLives = characterProperties[selectedCharacter] ? characterProperties[selectedCharacter].startLives : 5;
            for (let i = 0; i < playerLives; i++) {
                hearts += '♥️';
            }
            for (let i = playerLives; i < maxLives; i++) {
                hearts += '🖤';
            }
            livesDisplay.textContent = hearts;
        }

        function updateGoldDisplay() {
            goldDisplay.textContent = playerGold;
        }

        function updateKillsDisplay() {
            killsDisplay.textContent = enemiesKilled;
        }

        function showGameMessage(message, emoji = '') {
            if (currentMessageElement) {
                currentMessageElement.remove();
                currentMessageElement = null;
            }

            currentMessageElement = document.createElement('div');
            currentMessageElement.classList.add('game-overlay-message');

            if (emoji) {
                const emojiSpan = document.createElement('span');
                emojiSpan.classList.add('message-emoji');
                emojiSpan.textContent = emoji;
                currentMessageElement.appendChild(emojiSpan);
            }

            const messageText = document.createElement('span');
            messageText.textContent = message.toUpperCase();
            currentMessageElement.appendChild(messageText);

            gameContainer.appendChild(currentMessageElement);

            void currentMessageElement.offsetWidth;
            currentMessageElement.classList.add('show');

            setTimeout(() => {
                if (currentMessageElement) {
                    currentMessageElement.classList.remove('show');
                    currentMessageElement.addEventListener('transitionend', () => {
                        if (currentMessageElement && !currentMessageElement.classList.contains('show')) {
                            currentMessageElement.remove();
                            currentMessageElement = null;
                        }
                    }, { once: true });
                }
            }, 3000);
        }

        function gameLoop() {
            if (!gameRunning) return;

            updatePlayer();
            updateBullets();
            updateEnemies();
            updateBackgroundElements();
            updateItems();
            checkCollisions();
            handleActiveItems();
            updateImpactEffects();
            drawGame();

            if (bossSpawned && enemies.length === 0) {
                clearInterval(gameLoopInterval);
                clearInterval(enemySpawnInterval);
                clearTimeout(itemSpawnTimeout);
                clearTimeout(lightningTimeout);
                if (alienModeTimeout) {
                    clearTimeout(alienModeTimeout);
                    alienModeTimeout = null;
                }
                alienModeActive = false;
                ufoEffectElement.style.opacity = '0';
                ufoEffectElement.style.transform = ''; /* Reset transform when deactivating */


                gameRunning = false;
                bossLivesIncrease += 10;
                if (currentLevel === 5) {
                    showWellDoneScreen();
                } else {
                    showLevelCompleteScreen();
                }
            }
        }

        function drawGame() {
            ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            drawGround();

            backgroundElements.forEach(drawBackgroundElement);

            levelItems.forEach(drawLevelItem);

            const playerIcon = gamePlayer.logo;
            drawCharacter(gamePlayer, playerX, playerY, playerIcon, isCrouching, false);

            enemies.forEach(enemy => {
                const enemyIcon = enemy.type.icon;
                const enemyIsCrouching = enemy.isCrouching;
                const enemyIsFlipped = (enemy.type.icon === '👨‍🦽') ? false : true;

                drawCharacter(enemy, enemy.x, enemy.y, enemyIcon, enemyIsCrouching, enemyIsFlipped);
            });

            playerBullets.forEach(drawBullet);

            enemyBullets.forEach(drawBullet);

            ufoBullets.forEach(drawBullet);

            impactEffects.forEach(drawImpact);
        }

        function showLevelCompleteScreen() {
            levelCompleteScreen.classList.remove('hidden');
            controlsDiv.classList.add('hidden');
        }

        function showGameOverScreen() {
            clearInterval(gameLoopInterval);
            clearInterval(enemySpawnInterval);
            clearTimeout(itemSpawnTimeout);
            clearTimeout(lightningTimeout);
            if (alienModeTimeout) {
                clearTimeout(alienModeTimeout);
                alienModeTimeout = null;
            }
            alienModeActive = false;
            ufoEffectElement.style.opacity = '0';
            ufoEffectElement.style.transform = ''; /* Reset transform when game over */


            gameRunning = false;
            controlsDiv.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
        }

        function showWellDoneScreen() {
            controlsDiv.classList.add('hidden');
            wellDoneScreen.querySelector('#final-player-logo').textContent = gamePlayer.logo;
            wellDoneScreen.querySelector('#final-player-name').textContent = gamePlayer.name;
            wellDoneScreen.querySelector('#final-gold').textContent = playerGold;
            wellDoneScreen.querySelector('#final-kills').textContent = enemiesKilled;
            wellDoneScreen.querySelector('#final-deaths').textContent = playerDeaths;
            wellDoneScreen.classList.remove('hidden');
        }

        function resetPlayerPosition() {
            playerX = 50;
            playerY = groundHeight;
            playerVelocityY = 0;
            isPlayerOnGround = true;
        }

        function spawnBackgroundElements() {
            backgroundElements.length = 0;
            for (let i = 0; i < 15; i++) {
                const randomVal = Math.random();
                let icon;
                let sizeMultiplier;

                if (randomVal < 0.28) {
                    icon = '🌲';
                    sizeMultiplier = 8;
                } else if (randomVal < 0.56) {
                    icon = '🌳';
                    sizeMultiplier = 6;
                } else if (randomVal < 0.78) {
                    icon = '🌾';
                    sizeMultiplier = 0.25;
                } else {
                    icon = '🌱';
                    sizeMultiplier = 0.25;
                }

                const tempFontSize = getScaledFontSize(BASE_FONT_SIZE_BACKGROUND * sizeMultiplier);
                ctx.font = `${tempFontSize}px Arial`;
                const tempMetrics = getEmojiMetrics(icon, tempFontSize);

                backgroundElements.push({
                    icon: icon,
                    x: Math.random() * (gameCanvas.width * 1.5),
                    y: groundHeight,
                    sizeMultiplier: sizeMultiplier,
                    width: tempMetrics.width,
                    height: tempMetrics.height
                });
            }
        }

        function updateBackgroundElements() {
            const scrollSpeed = 0.3;
            for (let i = backgroundElements.length - 1; i >= 0; i--) {
                const elementObj = backgroundElements[i];

                let currentScrollSpeed = scrollSpeed;

                elementObj.x -= currentScrollSpeed;

                if (elementObj.x + elementObj.width < -elementObj.width) {
                    elementObj.x = gameCanvas.width + Math.random() * gameCanvas.width;
                }
            }
        }

        let playerVelocityY = 0;
        let isPlayerOnGround = true;

        function updatePlayer() {
            const playerCurrentFontSize = isCrouching ? getScaledFontSize(BASE_FONT_SIZE_PLAYER / 2) : getScaledFontSize(BASE_FONT_SIZE_PLAYER);
            const playerMetrics = getEmojiMetrics(gamePlayer.logo, playerCurrentFontSize);
            playerWidth = playerMetrics.width;
            playerHeight = playerMetrics.height;

            if (isJumping && isPlayerOnGround) {
                playerVelocityY = jumpSpeed;
                isJumping = false;
                isPlayerOnGround = false;
            }

            if (!isPlayerOnGround) {
                playerY += playerVelocityY;
                playerVelocityY -= gravity;
                if (playerY <= groundHeight) {
                    playerY = groundHeight;
                    isPlayerOnGround = true;
                    playerVelocityY = 0;
                }
            }
        }

        function firePlayerBullet() {
            const bulletFontSize = getScaledFontSize(BASE_FONT_SIZE_BULLET);
            const playerCurrentFontSize = isCrouching ? getScaledFontSize(BASE_FONT_SIZE_PLAYER / 2) : getScaledFontSize(BASE_FONT_SIZE_PLAYER);
            const playerMetrics = getEmojiMetrics(gamePlayer.logo, playerCurrentFontSize);
            const playerCurrentHeight = playerMetrics.height;

            const bulletMetrics = getEmojiMetrics(gamePlayer.bulletIcon, bulletFontSize);
            const bulletWidth = bulletMetrics.width;
            const bulletHeight = bulletMetrics.height;


            for (let i = 0; i < gamePlayer.bulletCount; i++) {
                let verticalOffset = 0;
                if (gamePlayer.bulletCount > 1) {
                    verticalOffset = (i - (gamePlayer.bulletCount - 1) / 2) * (playerCurrentHeight / 4);
                }

                const bulletX = playerX + playerWidth;
                const bulletYCanvas = (gameCanvas.height - playerY) - (playerCurrentHeight / 2) + (bulletHeight / 2) - verticalOffset;

                playerBullets.push({
                    icon: gamePlayer.bulletIcon,
                    x: bulletX,
                    y: bulletYCanvas,
                    damage: gamePlayer.bulletDamage,
                    rotation: 0,
                    width: bulletWidth,
                    height: bulletHeight,
                    type: 'player'
                });
            }
        }

        function fireEnemyBullet(enemy) {
            const bulletFontSize = getScaledFontSize(BASE_FONT_SIZE_BULLET);
            const enemyCurrentFontSize = getScaledFontSize(enemy.type.baseSizeModifier * BASE_FONT_SIZE_PLAYER);
            ctx.font = `${enemyCurrentFontSize}px Arial`;
            const enemyMetrics = getEmojiMetrics(enemy.type.icon, enemyCurrentFontSize);
            const enemyCurrentHeight = enemyMetrics.height;

            ctx.font = `${bulletFontSize}px Arial`;
            const bulletWidth = getEmojiMetrics(enemy.type.bulletIcon, bulletFontSize).width;
            const bulletHeight = getEmojiMetrics(enemy.type.bulletIcon, bulletFontSize).height;

            const bulletX = enemy.x;

            let bulletYCanvas = (gameCanvas.height - enemy.y) - (enemyCurrentHeight / 2) + (bulletHeight / 2);
            if (enemy.isBoss && enemy.isCrouching) {
                bulletYCanvas = (gameCanvas.height - enemy.y) - (enemyCurrentHeight / 4) + (bulletHeight / 2);
            }

            enemyBullets.push({
                icon: enemy.type.bulletIcon,
                x: bulletX,
                y: bulletYCanvas,
                speed: enemy.type.shootSpeed,
                rotation: 0,
                width: bulletWidth,
                height: bulletHeight,
                type: 'enemy'
            });
        }

        function createUFOBullet(targetEnemy) {
            // UFO position is now set dynamically by JS, so we need to get its actual position
            const ufoRect = ufoEffectElement.getBoundingClientRect();
            const gameAreaRect = gameArea.getBoundingClientRect();
            const ufoX = ufoRect.left - gameAreaRect.left + ufoRect.width / 2;
            const ufoY = ufoRect.top - gameAreaRect.top + ufoRect.height / 2;

            const bulletFontSize = getScaledFontSize(BASE_FONT_SIZE_BULLET);
            const bulletMetrics = getEmojiMetrics('👾', bulletFontSize);
            const bulletWidth = bulletMetrics.width;
            const bulletHeight = bulletMetrics.height;

            const targetX = targetEnemy.x + targetEnemy.width / 2;
            const targetY = (gameCanvas.height - targetEnemy.y - targetEnemy.height / 2);

            const angle = Math.atan2(targetY - ufoY, targetX - ufoX);
            const dx = Math.cos(angle) * ufoBulletSpeed;
            let dy = Math.sin(angle) * ufoBulletSpeed;

            ufoBullets.push({
                icon: '👾',
                x: ufoX - bulletWidth / 2,
                y: ufoY - bulletHeight / 2,
                damage: 1,
                rotation: 0,
                width: bulletWidth,
                height: bulletHeight,
                dx: dx,
                dy: dy,
                type: 'ufo'
            });
        }


        function takeDamage() {
            playerLives--;
            playerDeaths++;
            updateLivesDisplay();
            if (playerLives <= 0) {
                showGameOverScreen();
            }
        }

        function updateBullets() {
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                bullet.x += playerBulletSpeed;
                bullet.rotation = (bullet.rotation + 10) % 360;

                if (bullet.x > gameCanvas.width) {
                    playerBullets.splice(i, 1);
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x -= bullet.speed * gamePlayer.enemyShootSpeedModifier;
                bullet.rotation = (bullet.rotation + 10) % 360;

                if (bullet.x < 0) {
                    enemyBullets.splice(i, 1);
                }
            }

            for (let i = ufoBullets.length - 1; i >= 0; i--) {
                const bullet = ufoBullets[i];
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                bullet.rotation = (bullet.rotation + 10) % 360;

                if (bullet.x < -bullet.width || bullet.x > gameCanvas.width + bullet.width ||
                    bullet.y < -bullet.height || bullet.y > gameCanvas.height + bullet.height) {
                    ufoBullets.splice(i, 1);
                }
            }
        }

        function createImpactEffect(x, y, icon) {
            const impactLifeTime = 300;
            impactEffects.push({
                icon: icon,
                x: x,
                y: y,
                startTime: Date.now(),
                lifeTime: impactLifeTime
            });
        }

        function updateImpactEffects() {
            for (let i = impactEffects.length - 1; i >= 0; i--) {
                const impact = impactEffects[i];
                if (Date.now() - impact.startTime > impact.lifeTime) {
                    impactEffects.splice(i, 1);
                }
            }
        }

        function createEnemy(type, isBoss = false) {
            const enemyFontSize = getScaledFontSize(type.baseSizeModifier * BASE_FONT_SIZE_PLAYER);
            ctx.font = `${enemyFontSize}px Arial`;
            const enemyMetrics = getEmojiMetrics(type.icon, enemyFontSize);


            let initialX;
            if (isBoss) {
                initialX = gameCanvas.width - enemyMetrics.width - 5;
            } else {
                initialX = gameCanvas.width + Math.random() * 100;
            }

            let initialBossLives = type.lives;
            if (isBoss) {
                initialBossLives += bossLivesIncrease;
            }

            enemies.push({
                x: initialX,
                y: groundHeight,
                type: type,
                lives: initialBossLives,
                lastShotTime: Date.now(),
                isBoss: isBoss,
                velocityY: 0,
                isOnGround: true,
                lastJumpTime: 0,
                isCrouching: false,
                lastCrouchTime: 0,
                width: enemyMetrics.width,
                height: enemyMetrics.height,
                initialSpawnTime: Date.now()
            });
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                let currentEnemySpeed = enemy.type.speed * gamePlayer.enemySpeedModifier;

                if (!enemy.isBoss) {
                    enemy.x -= currentEnemySpeed;
                }


                let enemyCurrentFontSize = getScaledFontSize(enemy.type.baseSizeModifier * BASE_FONT_SIZE_PLAYER);
                if (enemy.isBoss && enemy.isCrouching) {
                    enemyCurrentFontSize = getScaledFontSize(enemy.type.baseSizeModifier * BASE_FONT_SIZE_PLAYER / 2);
                }
                ctx.font = `${enemyCurrentFontSize}px Arial`;
                const currentEnemyMetrics = getEmojiMetrics(enemy.type.icon, enemyCurrentFontSize);
                enemy.width = currentEnemyMetrics.width;
                enemy.height = currentEnemyMetrics.height;

                if (enemy.isBoss && enemy.type.canCrouch) {
                    if (!enemy.isCrouching && enemy.isOnGround && Math.random() < enemy.type.crouchFrequency && (Date.now() - enemy.lastCrouchTime > enemy.type.crouchDuration + 1000)) {
                        enemy.isCrouching = true;
                        enemy.lastCrouchTime = Date.now();
                    } else if (enemy.isCrouching && (Date.now() - enemy.lastCrouchTime > enemy.type.crouchDuration)) {
                        enemy.isCrouching = false;
                    }
                }

                let currentJumpFrequency = enemy.type.canJump ? 0.008 : 0;
                if (enemy.isBoss) {
                    currentJumpFrequency = enemy.type.jumpFrequency;
                }

                if (enemy.type.canJump && enemy.isOnGround && Math.random() < currentJumpFrequency && (Date.now() - enemy.lastJumpTime > 1000)) {
                    enemy.velocityY = enemy.type.jumpSpeed;
                    enemy.isOnGround = false;
                    enemy.lastJumpTime = Date.now();
                }

                if (!enemy.isOnGround) {
                    enemy.y += enemy.velocityY;
                    enemy.velocityY -= gravity;
                    if (enemy.y <= groundHeight) {
                        enemy.y = groundHeight;
                        enemy.isOnGround = true;
                        enemy.velocityY = 0;
                    }
                }

                if (enemy.x > 0 && enemy.x < gameCanvas.width && (Date.now() - enemy.lastShotTime > enemy.type.shootPause)) {
                    let numberOfEnemyBullets = 1;
                    if (enemy.isBoss && currentLevel >= 3) {
                        numberOfEnemyBullets = 2;
                    }
                    if (enemy.isBoss && currentLevel >= 5) {
                        numberOfEnemyBullets = 3;
                    }
                    for (let bulletIndex = 0; bulletIndex < numberOfEnemyBullets; bulletIndex++) {
                        fireEnemyBullet(enemy);
                    }
                    enemy.lastShotTime = Date.now();
                }

                if (enemy.x < -enemy.width && !enemy.isBoss) {
                    enemies.splice(i, 1);
                }
            }
        }


        function getBoundingBox(obj, isPlayer = false, isEnemy = false, isBullet = false, isItem = false, isUFO = false) {
            let width, height;
            let currentIcon;
            let currentFontSize;

            if (isPlayer) {
                currentIcon = gamePlayer.logo;
                currentFontSize = isCrouching ? getScaledFontSize(BASE_FONT_SIZE_PLAYER / 2) : getScaledFontSize(BASE_FONT_SIZE_PLAYER);
            } else if (isEnemy) {
                currentIcon = obj.type.icon;
                if (obj.isBoss && obj.isCrouching) {
                    currentFontSize = getScaledFontSize(obj.type.baseSizeModifier * BASE_FONT_SIZE_PLAYER / 2);
                } else {
                    currentFontSize = getScaledFontSize(obj.type.baseSizeModifier * BASE_FONT_SIZE_PLAYER);
                }
            } else if (isBullet) {
                currentIcon = obj.icon;
                currentFontSize = getScaledFontSize(BASE_FONT_SIZE_BULLET);
            } else if (isUFO) {
                // For UFO, get its position from its style properties
                const ufoRect = ufoEffectElement.getBoundingClientRect();
                const gameAreaRect = gameArea.getBoundingClientRect();
                const ufoCurrentFontSize = parseFloat(getComputedStyle(ufoEffectElement).fontSize);
                const ufoMetrics = getEmojiMetrics(ufoEffectElement.textContent, ufoCurrentFontSize);
                width = ufoMetrics.width;
                height = ufoMetrics.height;

                return {
                    left: ufoRect.left - gameAreaRect.left,
                    right: ufoRect.left - gameAreaRect.left + width,
                    top: ufoRect.top - gameAreaRect.top,
                    bottom: ufoRect.top - gameAreaRect.top + height,
                    width: width,
                    height: height
                };
            }
            else if (isItem) {
                currentIcon = obj.icon;
                currentFontSize = getScaledFontSize(BASE_FONT_SIZE_ITEM);
            } else {
                return { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 };
            }

            ctx.font = `${currentFontSize}px Arial`;
            const metrics = ctx.measureText(currentIcon);
            width = metrics.width;
            height = currentFontSize;

            let x = obj.x;
            let y;

            if (isPlayer || isEnemy || isItem) {
                y = gameCanvas.height - obj.y - height;
            } else if (isBullet) {
                y = obj.y;
            } else {
                 y = obj.y;
            }

            return {
                left: x,
                right: x + width,
                top: y,
                bottom: y + height,
                width: width,
                height: height
            };
        }

        function isColliding(rect1, rect2) {
            return rect1.left < rect2.right &&
                   rect1.right > rect2.left &&
                   rect1.top < rect2.bottom &&
                   rect2.top < rect1.bottom;
        }

        function checkCollisions() {
            const playerCurrentFontSize = isCrouching ? getScaledFontSize(BASE_FONT_SIZE_PLAYER / 2) : getScaledFontSize(BASE_FONT_SIZE_PLAYER);
            ctx.font = `${playerCurrentFontSize}px Arial`;
            const playerMetrics = getEmojiMetrics(gamePlayer.logo, playerCurrentFontSize);
            playerWidth = playerMetrics.width;
            playerHeight = playerMetrics.height;

            const playerBox = getBoundingBox({ x: playerX, y: playerY, logo: gamePlayer.logo }, true, false, false, false);

            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                const bulletBox = getBoundingBox(bullet, false, false, true, false);

                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const enemyBox = getBoundingBox(enemy, false, true, false, false);

                    if (enemy.isBoss && enemy.isCrouching) {
                        const crouchingBossHitBox = {
                            left: enemyBox.left,
                            right: enemyBox.right,
                            top: enemyBox.top + enemyBox.height / 2,
                            bottom: enemyBox.bottom,
                            width: enemyBox.width,
                            height: enemyBox.height / 2
                        };
                        if (!isColliding(bulletBox, crouchingBossHitBox)) {
                            continue;
                        }
                    }

                    if (isColliding(bulletBox, enemyBox)) {
                        createImpactEffect(bulletBox.left + bulletBox.width / 2, bulletBox.top + bulletBox.height / 2, '💢');
                        playerBullets.splice(i, 1);
                        enemy.lives -= bullet.damage;

                        if (enemy.lives <= 0) {
                            enemies.splice(j, 1);
                            enemiesKilled++;
                            playerGold += enemy.type.gold;
                            if (!enemy.isBoss) {
                                enemiesDefeatedInLevel++;
                            }
                            updateKillsDisplay();
                            updateGoldDisplay();
                        }
                        break;
                    }
                }
            }

            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const playerBullet = playerBullets[i];
                const pbBox = getBoundingBox(playerBullet, false, false, true, false);

                for (let j = enemyBullets.length - 1; j >= 0; j--) {
                    const enemyBullet = enemyBullets[j];
                    const ebBox = getBoundingBox(enemyBullet, false, false, true, false);

                    if (isColliding(pbBox, ebBox)) {
                        createImpactEffect(pbBox.left + pbBox.width / 2, pbBox.top + pbBox.height / 2, '💥');
                        playerBullets.splice(i, 1);
                        enemyBullets.splice(j, 1);
                        break;
                    }
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                const bulletBox = getBoundingBox(bullet, false, false, true, false);

                if (isColliding(bulletBox, playerBox)) {
                    createImpactEffect(bulletBox.left + bulletBox.width / 2, bulletBox.top + bulletBox.height / 2, '🍂');
                    enemyBullets.splice(i, 1);
                    takeDamage();
                }
            }

            if (alienModeActive) {
                const ufoBox = getBoundingBox({}, false, false, false, false, true); // Get UFO's actual position

                // UFO schießt auf alle sichtbaren Gegner, wenn Cooldown abgelaufen ist
                if (Date.now() - ufoLastDamageTime > ufoDamageInterval) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const enemyBox = getBoundingBox(enemy, false, true, false, false);

                        // Überprüfen, ob der Gegner im sichtbaren Bereich ist
                        if (enemy.x + enemy.width > 0 && enemy.x < gameCanvas.width) {
                            createUFOBullet(enemy);
                            // Direkter Schaden, da das UFO ununterbrochen schießt und als Laserschuss dienen soll
                            enemy.lives -= 1; // Kann auch auf 0 gesetzt werden, wenn es ein One-Hit-Kill sein soll
                            createImpactEffect(enemyBox.left + enemyBox.width / 2, enemyBox.top + enemyBox.height / 2, '⚡');

                            if (enemy.lives <= 0) {
                                enemies.splice(j, 1);
                                enemiesKilled++;
                                playerGold += enemy.type.gold;
                                if (!enemy.isBoss) {
                                    enemiesDefeatedInLevel++;
                                }
                                updateKillsDisplay();
                                updateGoldDisplay();
                            }
                        }
                    }
                    ufoLastDamageTime = Date.now(); // Cooldown zurücksetzen
                }

                for (let i = ufoBullets.length - 1; i >= 0; i--) {
                    const ufoBullet = ufoBullets[i];
                    const ubBox = getBoundingBox(ufoBullet, false, false, true, false);

                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const enemyBox = getBoundingBox(enemy, false, true, false, false);

                        if (isColliding(ubBox, enemyBox)) {
                            createImpactEffect(ubBox.left + ubBox.width / 2, ubBox.top + ubBox.height / 2, '⚡️');
                            ufoBullets.splice(i, 1);
                            enemy.lives -= ufoBullet.damage;

                            if (enemy.lives <= 0) {
                                enemies.splice(j, 1);
                                enemiesKilled++;
                                playerGold += enemy.type.gold;
                                if (!enemy.isBoss) {
                                    enemiesDefeatedInLevel++;
                                }
                                updateKillsDisplay();
                                updateGoldDisplay();
                            }
                            break;
                        }
                    }
                }
            }


            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const enemyBox = getBoundingBox(enemy, false, true, false, false);

                if (isColliding(playerBox, enemyBox)) {
                    takeDamage();
                    enemies.splice(i, 1);
                    if (!enemy.isBoss) {
                        enemiesDefeatedInLevel++;
                    }
                }
            }

            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                const bulletBox = getBoundingBox(bullet, false, false, true, false);

                for (let j = levelItems.length - 1; j >= 0; j--) {
                    const itemObject = levelItems[j];
                    const itemBox = getBoundingBox(itemObject, false, false, false, true);

                    if (isColliding(bulletBox, itemBox)) {
                        createImpactEffect(bulletBox.left + bulletBox.width / 2, bulletBox.top + bulletBox.height / 2, '✨');
                        playerBullets.splice(i, 1);
                        itemObject.lives -= bullet.damage;

                        if (itemObject.lives <= 0) {
                            if (itemObject.icon === '📦') {
                                itemObject.icon = itemObject.item.icon;
                                itemObject.isOpened = true;
                                setTimeout(() => {
                                    const index = levelItems.indexOf(itemObject);
                                    if (index > -1) {
                                        levelItems.splice(index, 1);
                                    }
                                    openItemBox(itemObject);
                                }, 1500);
                            }
                        }
                        break;
                    }
                }
            }

            for (let i = levelItems.length - 1; i >= 0; i--) {
                const itemObject = levelItems[i];
                const itemBox = getBoundingBox(itemObject, false, false, false, true);

                if (isColliding(playerBox, itemBox)) {
                    levelItems.splice(i, 1);
                    openItemBox(itemObject);
                }
            }
        }

        function spawnItemBox() {
            const itemBoxFontSize = getScaledFontSize(BASE_FONT_SIZE_ITEM);
            ctx.font = `${itemBoxFontSize}px Arial`;
            const itemBoxMetrics = getEmojiMetrics('📦', itemBoxFontSize);
            const itemBoxWidth = itemBoxMetrics.width;
            const itemBoxHeight = itemBoxMetrics.height;

            const randomX = gameCanvas.width + Math.random() * 200 + 50;
            const randomY = groundHeight;

            const random = Math.random() * 100;
            let chosenItemType;
            let cumulativeFreq = 0;
            const itemKeys = Object.keys(itemTypes);
            for (let i = 0; i < itemKeys.length; i++) {
                const key = itemKeys[i];
                cumulativeFreq += itemTypes[key].frequency;
                if (random < cumulativeFreq) {
                    chosenItemType = itemTypes[key];
                    break;
                }
            }
            if (!chosenItemType) {
                chosenItemType = itemTypes.gold;
            }

            levelItems.push({
                icon: '📦',
                x: randomX,
                y: randomY,
                item: chosenItemType,
                lives: chosenItemType.lives,
                width: itemBoxWidth,
                height: itemBoxHeight,
                isOpened: false
            });
        }

        function updateItems() {
            const itemSpeed = 1;
            for (let i = levelItems.length - 1; i >= 0; i--) {
                const itemBox = levelItems[i];
                itemBox.x -= itemSpeed;

                if (itemBox.x < -itemBox.width) {
                    levelItems.splice(i, 1);
                }
            }
        }

        function handleActiveItems() {
            for (let i = activeItems.length - 1; i >= 0; i--) {
                const item = activeItems[i];
                if (Date.now() - item.startTime > item.duration) {
                    if (item.type.reverse) {
                        item.type.reverse(gamePlayer);
                    }
                    activeItems.splice(i, 1);
                }
            }
        }

        function openItemBox(itemObject) {
            itemObject.item.apply(gamePlayer);
            if (itemObject.item.duration > 0) {
                activeItems.push({
                    type: itemObject.item,
                    startTime: Date.now(),
                    duration: itemObject.item.duration
                });
            }
            showGameMessage(`${itemObject.item.name} AKTIVIERT!`, itemObject.item.icon);
        }

        function activateAlienMode() {
            if (alienModeActive) {
                clearTimeout(alienModeTimeout);
            }

            moonElement.textContent = '🌟';
            gamePlayer.bulletDamage *= 2;
            alienModeActive = true;
            ufoEffectElement.style.opacity = '1';

            // Get UFO font size to calculate its dimensions
            const ufoFontSize = parseFloat(getComputedStyle(ufoEffectElement).fontSize);
            const ufoMetrics = getEmojiMetrics(ufoEffectElement.textContent, ufoFontSize);
            const ufoWidth = ufoMetrics.width;
            const ufoHeight = ufoMetrics.height;

            // Position UFO over the right edge
            // - ufoWidth: to ensure it's fully visible at the right edge
            // / 2: approximately center vertically in the upper half
            ufoEffectElement.style.left = `${gameCanvas.width - ufoWidth}px`;
            ufoEffectElement.style.top = `${gameCanvas.height * 0.2 - ufoHeight / 2}px`; /* Vertikal etwas höher platziert (20% der Höhe) */
            ufoEffectElement.style.transform = 'none'; /* Remove any previous centering transform */


            showGameMessage('ALIEN MODUS AKTIVIERT!', '👽');

            alienModeTimeout = setTimeout(() => {
                moonElement.textContent = '🌑';
                gamePlayer.bulletDamage /= 2;
                alienModeActive = false;
                ufoEffectElement.style.opacity = '0';
                ufoEffectElement.style.transform = ''; /* Reset transform when deactivating */
            }, 9000);
        }


        // --- Event Listener ---
        jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); isJumping = true; });
        jumpButton.addEventListener('touchend', () => { isJumping = false; });
        jumpButton.addEventListener('mousedown', () => { isJumping = true; });
        jumpButton.addEventListener('mouseup', () => { isJumping = false; });
        jumpButton.addEventListener('mouseleave', () => { isJumping = false; });

        crouchButton.addEventListener('touchstart', (e) => { e.preventDefault(); isCrouching = true; });
        crouchButton.addEventListener('touchend', () => { isCrouching = false; });
        crouchButton.addEventListener('mousedown', () => { isCrouching = true; });
        crouchButton.addEventListener('mouseup', () => { isCrouching = false; });
        crouchButton.addEventListener('mouseleave', () => { isCrouching = false; });

        shootButton.addEventListener('click', (e) => {
            e.preventDefault();
            firePlayerBullet();
        });
        shootButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            firePlayerBullet();
        });


        function checkStartButtonVisibility() {
            if (playerNameInput.value.trim() !== '' && selectedCharacter !== null) {
                startGameButton.classList.remove('hidden');
            }
             else {
                startGameButton.classList.add('hidden');
            }
        }

        playerNameInput.addEventListener('input', checkStartButtonVisibility);

        characterSelection.addEventListener('click', (e) => {
            const targetCard = e.target.closest('.character-card');
            if (targetCard) {
                document.querySelectorAll('.character-card').forEach(card => card.classList.remove('selected'));
                targetCard.classList.add('selected');
                selectedCharacter = targetCard.dataset.character;
                checkStartButtonVisibility();
            }
        });

        startGameButton.addEventListener('click', () => {
            playerName = playerNameInput.value.trim();
            startGame();
        });

        function populateShop() {
            shopItemsContainer.innerHTML = '';
            for (const key in shopItems) {
                const item = shopItems[key];
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('shop-item');
                if (item.purchased) {
                    itemDiv.classList.add('purchased');
                }
                itemDiv.innerHTML = `
                    <div class="shop-item-info">
                        <span class="item-icon">${item.icon}</span>
                        <span class="item-name">${item.name}</span>
                    </div>
                    <span class="price">${item.price}🪙</span>
                    <button data-item="${key}" ${item.purchased ? 'disabled' : ''}>KAUFEN</button>
                `;
                shopItemsContainer.appendChild(itemDiv);
            }
        }

        shopItemsContainer.addEventListener('click', (e) => {
            const buyButton = e.target.closest('button');
            if (buyButton && !buyButton.disabled) {
                const itemId = buyButton.dataset.item;
                const item = shopItems[itemId];

                if (playerGold >= item.price) {
                    playerGold -= item.price;
                    updateGoldDisplay();
                    item.purchased = true;
                    if (item.apply) {
                        item.apply(gamePlayer);
                    }
                    populateShop();
                }
                else {
                    alert('Nicht genug Gold!');
                }
            }
        });

        shopButton.addEventListener('click', () => {
            levelCompleteScreen.classList.add('hidden');
            shopScreen.classList.remove('hidden');
            populateShop();
        });

        nextLevelButton.addEventListener('click', () => {
            levelCompleteScreen.classList.add('hidden');
            startLevel(currentLevel + 1);
            gameRunning = true;
            gameLoopInterval = setInterval(gameLoop, 1000 / 60);
            controlsDiv.classList.remove('hidden');
        });

        quitGameButton.addEventListener('click', () => {
            initGame();
        });

        restartButton.addEventListener('click', () => {
            initGame();
        });

        backToStartButton.addEventListener('click', () => {
            initGame();
        });

        backToLevelCompleteButton.addEventListener('click', () => {
            shopScreen.classList.add('hidden');
            levelCompleteScreen.classList.remove('hidden');
        });

        function resizeGameArea() {
            gameCanvas.width = gameArea.offsetWidth;
            gameCanvas.height = gameArea.offsetHeight;

            groundHeight = gameCanvas.height * GROUND_HEIGHT_RATIO;

            if (gameRunning && isPlayerOnGround) {
                playerY = groundHeight;
            } else if (!gameRunning) {
                playerY = groundHeight;
            }

            spawnBackgroundElements();

            enemies.forEach(enemy => {
                if (enemy.isOnGround) {
                    enemy.y = groundHeight;
                }
                if (enemy.isBoss) {
                     const enemyFontSize = getScaledFontSize(enemy.type.baseSizeModifier * BASE_FONT_SIZE_PLAYER);
                     ctx.font = `${enemyFontSize}px Arial`;
                     const enemyMetrics = getEmojiMetrics(enemy.type.icon, enemyFontSize);
                     enemy.x = gameCanvas.width - enemyMetrics.width - 5;
                }
            });


            levelItems.forEach(item => {
                item.y = groundHeight;
            });

            if (gameRunning && moonElement) {
                const tempFontSize = parseFloat(getComputedStyle(lightningEffectElement).fontSize);
                const tempMetrics = getEmojiMetrics(lightningEffectElement.textContent, tempFontSize);
                lightningEffectElement.style.width = `${tempMetrics.width}px`;
                lightningEffectElement.style.height = `${tempMetrics.height}px`;

                const moonRect = moonElement.getBoundingClientRect();
                const gameAreaRect = gameArea.getBoundingClientRect();

                const lightningX = (moonRect.left - gameAreaRect.left - lightningEffectElement.offsetWidth - 10);
                const lightningY = (moonRect.top - gameAreaRect.top + 30);

                lightningEffectElement.style.left = `${lightningX}px`;
                lightningEffectElement.style.top = `${lightningY}px`;
            }

            // Reposition UFO if alien mode is active
            if (alienModeActive && ufoEffectElement) {
                const ufoFontSize = parseFloat(getComputedStyle(ufoEffectElement).fontSize);
                const ufoMetrics = getEmojiMetrics(ufoEffectElement.textContent, ufoFontSize);
                const ufoWidth = ufoMetrics.width;
                const ufoHeight = ufoMetrics.height;

                ufoEffectElement.style.left = `${gameCanvas.width - ufoWidth}px`;
                ufoEffectElement.style.top = `${gameCanvas.height * 0.2 - ufoHeight / 2}px`;
            }

            // Update button sizes dynamically
            const shootButtonComputedStyle = getComputedStyle(shootButton);
            const shootButtonWidth = shootButton.offsetWidth;
            const shootButtonHeight = shootButton.offsetHeight;

            // Set CSS custom properties for jump and crouch buttons
            controlsDiv.style.setProperty('--button-width', `${shootButtonWidth}px`);
            controlsDiv.style.setProperty('--button-height', `${shootButtonHeight}px`);

            drawGame();
        }

        window.addEventListener('resize', resizeGameArea);

        // Initial setup
        initGame();
    </script>
</body>
</html>
